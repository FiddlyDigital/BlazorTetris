@page "/"
@using BlazorTetris.Domain
@using System.Drawing
@using Blazor.Extensions.Canvas.Canvas2D

@inject IJSRuntime JsRuntime;

<PageTitle>Blazor Tetris</PageTitle>
<h3>Blazor Tetris</h3>

@if (player != null)
{
    <div id="score">@player.score</div>
}

<BECanvas Width="240" Height="400" @ref="_canvasReference"></BECanvas>

@code {
    BECanvasComponent _canvasReference = null;
    Canvas2DContext _outputCanvasContext;
    private Arena arena;
    private Player player;
    private int dropCounter = 0;
    private int dropInterval = 1000;
    private int lastTime = 0;
    private string[] colors = ["purple", "yellow", "orange", "blue", "aqua", "green", "red"];

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender){
            return;
        }

        _outputCanvasContext = await _canvasReference.CreateCanvas2DAsync();
        await _outputCanvasContext.ScaleAsync(20, 20);

        arena = new Arena();
        player = new Player(arena);
        this.player.reset();

        await JsRuntime.InvokeAsync<object>("initGame", DotNetObjectReference.Create(this));
    }


    private async ValueTask clear()
    {
        await _outputCanvasContext.SetFillStyleAsync("#000");
        await _outputCanvasContext.FillRectAsync(0, 0, this._canvasReference.Width, this._canvasReference.Height);
    }

    private async ValueTask draw()
    {
        await this.clear();
        await this.drawMatrix(this.arena.matrix, new Point(0, 0));
        await this.drawMatrix(this.player.matrix, this.player.pos);
    }

    private async ValueTask drawMatrix(int[][] matrix, Point offset)
    {
        for(int y = 0; y < matrix.Length; y++)
        {
            for(int x = 0; x < matrix[y].Length; x++)
            {
                int val = matrix[y][x];
                if (val > 0)
                {
                    await _outputCanvasContext.SetFillStyleAsync(colors[val - 1]);
                    await _outputCanvasContext.FillRectAsync(x + offset.X, y + offset.Y, 1, 1);
                }
            }
        }
    }

    [JSInvokable]
    public async ValueTask GameLoop(double dtime = 0)
    {
        int time = (int)Math.Floor(dtime);
        int timeDelta = time - lastTime;
        this.lastTime = time;

        this.dropCounter += timeDelta;
        if (this.dropCounter >= this.dropInterval)
        {
            this.player.drop();
            this.dropCounter = 0;
        }

        await this.draw();
    }

    [JSInvokable]
    public async ValueTask KeyPressed(string key)
    {
        switch (key)
        {
            case "W": // W
            case "w": // W
                this.player.move(-1);
                break;
            case "S": // Down
            case "s": // S
                this.player.drop();
                break;
            case "A": // Turn Left
            case "a": // A
                this.player.move(-1);
                break;
            case "D": // Right
            case "d": // D
                this.player.move(1);
                break;
            case "Q": // Q
            case "q":
                this.player.rotate(-1);
                break;
            case "E": // E
            case "e":
                this.player.rotate(1);
                break;
        }
    }
}
